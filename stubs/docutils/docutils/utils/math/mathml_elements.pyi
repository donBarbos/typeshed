import xml.etree.ElementTree as ET
from _typeshed import Incomplete
from typing import Final, SupportsIndex
from typing_extensions import Self

GLOBAL_ATTRIBUTES: Final[tuple[str, ...]]

class MathElement(ET.Element):
    nchildren: int | None
    parent: Incomplete
    def __init__(self, *children, **attributes) -> None: ...
    @staticmethod
    def a_str(v: object) -> str: ...
    def set(self, key: str, value: object) -> None: ...
    def __setitem__(self, key: SupportsIndex, value) -> None: ...
    def is_full(self) -> bool: ...
    def close(self): ...
    def append(self, element) -> Self: ...
    def extend(self, elements) -> Self: ...
    def pop(self, index: int = -1): ...
    def in_block(self) -> bool: ...
    def indent_xml(self, space: str = "  ", level: int = 0) -> None: ...
    def unindent_xml(self) -> None: ...
    def toxml(self, encoding: str | None = None) -> str: ...

class MathRow(MathElement): ...

class MathSchema(MathElement):
    nchildren: int
    switch: Incomplete
    def __init__(self, *children, **kwargs) -> None: ...
    def append(self, element): ...

class MathToken(MathElement):
    nchildren: int
    text: Incomplete
    def __init__(self, text, **attributes) -> None: ...

class math(MathRow): ...
class mtext(MathToken): ...
class mi(MathToken): ...
class mn(MathToken): ...
class mo(MathToken): ...

class mspace(MathElement):
    nchildren: int

class mrow(MathRow):
    def transfer_attributes(self, other) -> None: ...
    def close(self): ...

class mfrac(MathSchema): ...

class msqrt(MathRow):
    nchildren: int

class mroot(MathSchema): ...
class mstyle(MathRow): ...
class merror(MathRow): ...

class menclose(MathRow):
    nchildren: int

class mpadded(MathRow): ...

class mphantom(MathRow):
    nchildren: int

class msub(MathSchema): ...
class msup(MathSchema): ...

class msubsup(MathSchema):
    nchildren: int

class munder(msub): ...
class mover(msup): ...
class munderover(msubsup): ...
class mtable(MathElement): ...
class mtr(MathRow): ...
class mtd(MathRow): ...
